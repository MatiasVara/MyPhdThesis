\chapter{Conclusion}
\label{ch:conclusions}
In this thesis, we have proposed \bcool, a dedicated (meta)language that enables language integrators to specify coordination patterns between heterogeneous languages. By relying on this specification at language level, system designers can automatically generate the coordination between heterogeneous models. Such a model of coordination can be used to verify and execute the coordinated system. In the following, we summarize the main findings of this thesis. We finish this chapter by proposing future works. 

\section{Overview}
	
This thesis has focused on the coordination of heterogeneous behavioral models to provide execution and verification of the global system behavior. We studied the state-of-art approaches that aim at getting the global representation of a heterogeneous system, in both structural and behavioral way. 

We first studied approaches that propose to compose models into a new model. The composition of models has been automated by looking for correspondences between heterogeneous models, and then composing them into a new model. We have noted that most of the approaches consider structural correspondences and only few consider also the behavior of models to find similarities. These approaches have achieved to automate the composition of model by reifying the composition at language level. However, these approaches only consider structural models.  

Then, we have studied approaches that compose languages to get a new language. Most of these approaches focus on the composition of the syntax of languages into a new syntax. Only Semantics Anchoring~\cite{semanticsanchoring} proposes to compose behavioral semantics. We have determined that these approaches proposed to model a heterogeneous system by relying on a single language which results from the composition of other languages. From our point of view, these approaches are not suitable for separation of preoccupations and development of a single system by various domain experts who focus on a specific part of the system. 

We have presented a different kind of approaches that propose to coordinate the behavior of models. They propose to specify the interaction between heterogeneous behavioral models by using a dedicated language, \ie Coordination Languages and ADLs. To ease the task of a system designer, ADLs' community has successfully identified the need of connector types. Thus, a system designer has only to instantiate and bind connector types as needed by its architecture. Furthermore, in some of these approaches, the coordination is expressed in a formal language thus providing reasoning about the coordinated system. We have noted, however, that in coordination languages and ADLs, the coordination is specified between particular models. With the increasing number and heterogeneity of the components, the manual coordination of models can quickly become difficult and error prone. We have determined that, by relying on Coordination Languages and ADLs, a system designer only captures the solution for one single problem but he does not specify a systematic way to coordinate models. 
 
We have studied four approaches that identified that the instantiation and binding of connector types can be a systematic activity the system designer repeats many times and may consequently be defined as a coordination pattern. Such a pattern is based on the \emph{know-how} of the system designer and sometimes on naming or organizational conventions adopted by the models. These approaches have captured the specification of a behavioral coordination pattern inside a tool/framework to automate the instantiation and binding of connector types. These approaches go one step beyond Coordination Languages and ADLs by leveraging on the know-how of a system designer. However, we have noted that, in these approaches, the knowledge about the coordination is hidden inside a tool, thus limiting reasoning. Moreover, they express the coordination in a GPL thus limiting the verification and validation of the coordinated system. Based on the state-of-art approaches, we have determined that:

\begin{itemize}
\item The specification of coordination patterns between language is specified at language level;
	 
\item The specification of coordination patterns should be done by using a dedicated language; 
	 
\item The coordination between models should be generated by using a formal language to enable system designers to verify and validate the coordinated system. 		
\end{itemize}

We have determined that the lack of a systematic way to specify a coordination pattern makes these four approaches ad-hoc and not flexible. Furthermore, this prevents a wider adoption of this sort of approaches. To understand how existing tools and frameworks have achieved to capture a given coordination pattern, we proposed a framework for the specification of coordination patterns. We have determined three building-blocks:

	\begin{itemize}
	\item A Language Behavioral Interface, which exposes partial information about the syntax and the behavioral semantics of languages for coordination purpose; 
	
	\item A Correspondence Rule, which specifies what and when elements from different languages must be coordinated;
	
	\item A Coordination Rule, which specify how the selected elements must be coordinated. 
\end{itemize}

Then, we have used this framework to compare existing approaches. Based on this comparison, we stated the requirements to make them more flexible and better customizable. More precisely, we proposed the requirements for a language to specify coordination patterns. These requirements tend to improve existing approaches in the customization of coordination patterns between heterogeneous languages.

Based on these requirements, we proposed \bcool, a dedicated (meta)language to capture coordination patterns between languages. \bcool is a particular implementation of the proposed framework. We based on a language behavioral interface made of event types, \ie \dse. These event types act as coordination points on the language behavioral semantics. Then, we have proposed to specify coordination patterns by using operators that define a correspondence matching that selects instances of \dse, and a coordination rule that defines how the selected instances of \dse must be coordinated. Using \bcool, the know-how of a system designer is made explicit, stored and shared in libraries. Furthermore, such coordination patterns, expressed at the language level, can be applied on particular models to automatically generate the corresponding coordination model in \ccsl language. The use of the formal \ccsl language to express the coordination allowed us to provide execution and verification of the coordinated system.
	
We implemented \bcool as a set of Eclipse plugins integrated into the GEMOC studio. The studio proposes a language workbench and a modeling workbench. In the language workbench, an language integrator can develop operators between languages. Then, in the modeling workbench, a system designer can use these operators to automate the coordination of models. We have proposed a dedicated language named \bflow that allows a system designer to specify what operators are applied on a set of models. Then, from this specification, a system designer can generate a model of coordination in \ccsl so that the whole system can be executed and verified.  
	
To validate our approach, we have presented the coordination of the heterogeneous models of a surveillance camera system. We modeled the different parts of the system by using the TFSM and Activity languages. To coordinate these models, we specified in \bcool three coordination patterns that we captured by using three operators. Unlike coordination frameworks in which the semantics of the coordination is hidden, we have explicitly specified these patterns by using a dedicated language. We used this specification to generate the coordination for the surveillance camera system, and then we executed the overall system.

	  
\section{Future Works}
\bcool provides some perspectives to extend and to improve the work carried out in this thesis. We list the propositions we consider essential to the continuity of this work:

\begin{itemize}
	\item \textbf{Extending \bcool to support the coordination of data:} System designers build coordination models to specify how models interact. The interactions between models can rely on events but also on data, \ie data-driven coordination. In this case, a model exchanges data with another model. With \bcool, we have managed interactions that rely on events, \ie control-driven coordination. To support the specification of coordination patterns that involve the exchange of data between models, we have to extend \bcool to support data driven coordination. More precisely, we have to add a way to specify when a value of a variable in a model is carried to a new value in a variable in another model. 
	%This makes arrive several questions:
	%		\begin{itemize}
	%			\item \emph{What} value must be carry, \eg the first one, the last one;
	%			\item \emph{When} the value of two variables must be synchronized, \eg immediately after one of them changes, after a period;
	%			\item \emph{How} the value of a variable must be carry from one model to another, \eg the same value, with some conversion. 
	%		\end{itemize}
	In \bcool, such information should be encoded in a \emph{data coordination rule}. In addition, the current coordination rule should be used to synchronize the events associated with the change of the value of a variable. Thus, the resulting model of coordination would have some \ccsl specification but also some code that represents the exchange of data between models. During the execution of models, such an exchange of data could be handled by the heterogeneous engine. Thus, a configuration file should be also generated to tell the engine what and when data from different models must be exchanged.	
	   	 
	\item \textbf{Generalizing the specification of correspondences by using a dedicated language:} In \bcool, the correspondence matching can capture implicit and explicit correspondences between elements of models. Currently, the explicit correspondence is only supported if one of the metamodel is modified to refer concepts from a different metamodel. To avoid such modification, we need a language to specify correspondences between concepts from different languages without modifying the metamodels (\eg like in megamodels~\cite{bezivinmegamodels}). This is, for instance, the case of Atlas Model Weaver~\cite{amwbib}, a tool that enables to create links between model elements. In~\cite{amwcompobib}, such links are used for model composition. Once links between models are established, a model transformation written in ATL can compose the model elements into a composed model. In our case, these links could be used to identify the elements to be coordinated. This is interesting, for instance, in the case of allocation in which there is a model of the hardware, a model of the application and a mapping model that is often generated by using some heuristic. Such a mapping model contains the links between the application model and the hardware model that represent the deployment. The mapping model could be the input for a \bcool specification to generate the coordination model that represents the deployment between the hardware model and the platform model.
	%\item \textbf{Extending \bcool to generate a model of coordination in other language:} \bcool relies on \ccsl to express the coordination. However, we could rely on other coordination language to take advantages of the tooling from other environment. To do so, we have to investigate if the current event relations can be translated to another coordination language.\todo{bof...}
	
	\item \textbf{Using \bcool for the synthesis of the orchestrator for Co-Simulation of Functional Mock-up Units:} The analysis of Cyber-Physical Systems (CPS) involves the use of physical components (for instance described by differential equations evaluated according to the continuous time simulation paradigm) but it also involves the use of cyber components (usually relying on discrete time or discrete event simulation paradigms). Each language comes with existing tooling and several simulation tools and techniques are needed for CPS simulation and analysis. In this context, the Functional Mock-up Interface (FMI)~\cite{fmibib2} is a tool independent standard to support the co-simulation of dynamic models. The FMI standard provides a well defined specification and API to integrate heterogeneous simulation components. One key requirement for Co-Simulation via FMI is to develop a Master Algorithm that orchestrates the steps of Co-Simulation~\cite{fmibib}. For instance, the master algorithm has to control the data exchange and the time advancement among individual simulations. The FMI standard, however, does not describe or limit the implementation of the master algorithms. Currently, it is specified each time a particular system has to be co-simulated, which remains tedious and error prone. An interesting future work would be to generate such algorithm from a \bcool specification and the particular model used. Currently, the control and timing coordination is well managed by \bcool. However, to exploit the data exchange proposed by the FMI standard, it is mandatory to first extend \bcool to support data-driven coordination. 
	
	\item \textbf{Generalizing the specification of coordination patterns between existing modeling languages:} The development of heterogeneous system is currently done by using different existing modeling languages like Matlab, SDL or Modelica, which are developed by using very different technologies. To specify coordination patterns between these languages, we have to investigate how to add support for existing modeling languages in \bcool. Currently, to capture the specification of coordination patterns, we rely on partial information about the syntax and the behavioral semantics of languages that is contained in the language behavioral interface. It is thus mandatory that current modeling languages expose part of its syntax and behavioral semantics. The language behavioral interface may be a standard way to do it. In other words, modeling languages could provide a language behavioral interface for coordination purpose.    
				
		%\item It is thus mandatory a standard language behavioral interface. Such a language behavioral interface may be generated from code.   
	

	
	

	

	
		
				%\item To analyze CPS, some components can be easily described by differential equations, while others like communication networks require Discrete-Event Simulation (DEVS) techniques. As a result, several simulation tools and techniques are needed for CPS simulation and analysis. In particular, Co-Simulation (Cooperative Simulation) enables system designers to simulate individual components using different simulation tools.   
				
				%\item Cyber-Physical Systems (CPS) are composed of several collaborating physical and computing components that interact through embedded communication capabilities. 
		
		
		
		%\item Theoretically, an MA for direct co-ordination among FMUs can be developed for each distributed simulation problem, but that would be expensive and subject to errors.
		
\end{itemize}