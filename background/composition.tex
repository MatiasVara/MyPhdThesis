\section{Composition Approaches}
Model composition is a modeling approach used in software engineering to combine models with a specific purpose. Clavreul~\cite{clavreulmodelcompo} defines model composition as the activity that "enables to build a system from the union of independent or dependent software artifacts". A model is built based on a language that it is described by its meta model. A metamodel is a model that is developed by using a meta meta language, \eg MOF, ECORE. A metamodel has the concepts and relations to define a model.

Model composition proposes to specify \emph{correspondences} between the elements of the models (or meta-models) to be combined. Clavreul also identifies various \emph{interpretations} to these correspondences. An interpretation defines how the concepts are combined into a new model/language element. In the following, we rely on this vocabulary to analyze the state of art approaches. We categorize the current approaches into approaches that compose models and approaches that compose meta models. We name the former \emph{Composition of Model Approaches} and the later \emph{Composition of Languages Approaches}.    

Composition of model approaches have as goal to get a resulting model that is built by combining one or more models of the same language or from different languages. The resulting model can conform to input models or to a different metamodel. In these approaches, a set of correspondences define \emph{What} model elements must be composed, and the interpretation \emph{How} the selected element must be composed. However, the specification of the correspondence between models can be tedious and error prone depending on the size of the models and the number of the model. In order to automate the composition of structural models,~\cite{mergemanifest} identified that the composition between two models always relies on a \emph{merging} of structures. The merging is associated with an operator that takes two models as input and applies a \emph{relationship}. The relationship contains a set of correspondence between model elements. Then, they propose to automate the generation of the relationship by relying on a \emph{matching} operator. The relationships together with the merge operator are used to generate a new model. In this work, authors suppose input and output models conform to the same language, however, they conclude that the framework could be extended to the heterogeneous case. By relying on this framework, authors have achieved to compare different approaches of model composition. However, they do not propose an implementation of the framework. 

In~\cite{kompose}, authors also identify that the composition of models can be automated by relying on a matching and merging operator. The matching operator specifies which concepts from different languages are related. The merge operator specifies how the matched elements are combined. They implement the framework in a tool named Kompose which is based on the meta meta language Ecore. This allows the composition of models that conform to different metamodels. However, the metamodels must rely on Ecore. The output model must conform to a metamodel that conform to Ecore. This approach enables the customization of the matching and merging operator. 

However, the customization is manually done by a developer. The operators must be changed if a metamodel changes. To ease this task, Epsilon~\cite{epsilon}\footnote{http://www.eclipse.org/epsilon/} provides dedicated languages to define both the matching and merging. The matching is specified in the \emph{Epsilon Comparison Language} (ECL) and the merging is specified in the \emph{Epsilon Merging Language} (EML). The ECL is used to define \emph{matching rules} that enable the developer to specify correspondences between concepts of two metamodels. Matching rules apply between models and select elements that must be combined. Then, the EML is used to define \emph{merging rules} that specify how the matched elements must be combined. This results in a new model. The metamodel of both the input models and the output models must conform to Ecore.

The approaches previously studied only focus on structural similarities between models thus ignoring their semantics. In contrast, other approaches have concentrated on establishing semantic correspondences between models. They also rely on matching and merging operators, but they consider both structural and semantic information in the models. In the following, we review some of these approaches.  

Nejati et. al~\cite{compostatechartsbib} propose to represent the behavior of models by using statecharts. They propose an automatic approach to compose statecharts into a new statechart that represent the resulting behavior. The approach is based on a matching and merging operator, however, these operators rely on both structural and semantic information in the models. The matching operator is made of a combination of a \emph{static matching} and a \emph{behavioral matching}. The static matching identifies correspondence relationships between states by relying on theirs names. The static matching is thus independent of the semantics of statechart and it is not different that the correspondence presented in the previous approaches. The behavioral matching identifies correspondence relationships between states by relying on their behavior. \todo{For instance, in this work correspondence between states rely on measuring how close the behaviours of one state are to those of another.
Our algorithm iteratively computes a similarity degree for every pair (s, t) of states by aggregating the similarity degrees between the immediate neighbours of s and those of t. By neighbours, we mean either successor/child states (forward neighbours) or predecessor/parent states (backward neighbours) depending on which bisimilarity notion is being used.
The matching operator returns a set of correspondence. Since matching is a heuristic process, ρ should be reviewed and, if necessary, adjusted by the user.
The merge operator takes as input two models and the p correspondence and the output is a merged model if ρ satisfies certain sanity checks. Otherwise, a subset of ρ violating the checks is identified.
We provide a procedure for constructing behaviour-preserving merges that also respect the hierarchical structuring of the input models.}
       

   




\todo{Composition of language approaches use correspondence rules to associate concepts of various DSMLs in order to generate a new DSML.}



