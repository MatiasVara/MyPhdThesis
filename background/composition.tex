\section{Composition Approaches}
\subsection{Overview}
Model composition is a modeling approach used in software engineering to combine models with a specific purpose. Clavreul~\cite{clavreulmodelcompo} defines model composition as the activity that ``\textit{enables to build a system from the union of independent or dependent software artifacts}''. A model is built based on a language that it is described by its meta model. A metamodel is a model that is developed by using a meta meta language, \eg MOF, ECORE. A metamodel has the concepts and relations to define a model.

Model composition proposes to specify \emph{correspondences} between the elements of the models (or meta-models) to be combined. Clavreul also identifies various \emph{interpretations} to these correspondences. An interpretation defines how the concepts are combined into a new model/language element. In the following, we rely on this vocabulary to analyze the state of art approaches. We categorize the current approaches into approaches that compose models and approaches that compose meta models. We name the former \emph{Composition of Model Approaches} and the later \emph{Composition of Languages Approaches}.    

Composition of model approaches have as goal to get a resulting model that is built by combining one or more models of the same language or from different languages. The resulting model can conform to input models or to a different metamodel. In these approaches, correspondences define \emph{What} model elements must be composed, and the interpretation \emph{How} the selected element must be composed. However, the specification of the correspondence for each pair of models can be tedious and error prone. In order to automate the composition of models,~\cite{mergemanifest} identified that the composition between two models always relies on a \emph{merging} of structures. The merging is associated with an operator that takes two models as input and applies a \emph{relationship}. The relationship contains correspondence between model elements. This approach proposes to automate the generation of the relationships by relying on a \emph{matching} operator that looks for correspondence models. The relationships together with the merge operator are used to generate a new model in which the matched elements are composed into a new element. In this work, authors suppose input and output models conform to the same language, however, they conclude that the framework could be extended to the heterogeneous case. By relying on this framework, authors have achieved to compare different approaches of model composition. However, they do not propose an implementation of the framework. 

Differently, in~\cite{kompose}, authors also identified that the composition of models can be automated by relying on a matching and merging operator. The matching operator specifies which concepts from different languages are related. The merge operator specifies how the matched elements are combined. They implemented the framework in a tool named Kompose which is based on the meta meta language Ecore. This allows the composition of models that conform to different metamodels. However, the metamodels must rely on Ecore. The output model must conform to a metamodel that conform to Ecore. This approach enables the customization of the matching and merging operator. However, the customization is manually done by a developer. The operators must be changed if one of the metamodels change. 

To ease this task, Epsilon~\cite{epsilon}\footnote{http://www.eclipse.org/epsilon/} provides dedicated languages to define both the matching and merging. The matching is specified in the \emph{Epsilon Comparison Language} (ECL) and the merging is specified in the \emph{Epsilon Merging Language} (EML). The ECL is used to define \emph{matching rules} that enable the developer to specify correspondences between concepts of two metamodels. Matching rules apply between models and select elements that must be combined. Then, the EML is used to define \emph{merging rules} that specify how the matched elements must be combined. This results in a new model. The metamodel of both the input models and the output models must conform to Ecore.

\todo{To illustrate by using a Epsilon Specification}

The approaches previously studied only focus on structural similarities between models thus ignoring their semantics. In contrast, other approaches have concentrated on establishing semantic correspondences between models. They also rely on matching and merging operators, but they consider both structural and semantic information in the models. In the following, we review some of these approaches.  

Nejati et. al~\cite{compostatechartsbib} propose to represent the behavior of models by using statecharts. They propose an automatic approach to compose statecharts into a new statechart that represent the resulting behavior. The approach is based on a matching and merging operator, however, these operators rely on both structural and semantic information in the models. The matching operator is made of a combination of a \emph{static matching} and a \emph{behavioral matching}. The static matching identifies correspondence relationships between states by relying on theirs names. Thus, it is independent of the semantics of statechart and it is not different that the correspondence presented in the previous approaches. Conversely, the behavioral matching identifies correspondence relationships between states by relying on their behavior. For instance, the approach relies on measuring how close the behaviours of one state are to those of another. To do so, they compute a similarity degree for every pair of states by comparing the immediate neighbors of each pair of states. In this approach, a neighbor is either a successor/child states (forward neighbours) or a predecessor/parent states (backward neighbours). By relying on a static and behavioral matching, the matching operator returns a set of correspondence between states. Then, the merge operator takes as input two statecharts and the correspondences and generates as output an statechart model.
       
Aspect Oriented Modeling approaches~\cite{weavingbib} also consider the dynamic properties of models for the composition. However, in these approaches, the mechanism used to compose models is different. One model plays the role of \emph{base} and other the role of \emph{aspects}, both models conform to the same language. The composition of aspects into the base model is called \emph{weaving}. An aspect is made of a \emph{pointcut} and an \emph{advince}. The pointcut is a predicate over a model that is used to select relevant model elements called \emph{join points}. The join points are correspondence between the aspects and the base model. During the weaving, the join points are replaced by the advince, \ie the elements of a model (aspects), conform to a meta-model, are injected (woven) to another model that conforms to the same meta-model. In some approaches, the weaving of aspects is done by considering the behavior of the models used. For example, in~\cite{sequenceweavingbib,rambib,composdbib}, the behavior of a model is represented by a Sequence Diagram (base model). An aspect is defined as a pair of SD: one SD serves as a pointcut (specification of the behavior to detect), and one serves as an advice (representing the expected behavior at the join point). When a behavior in the base model is detected, the join point is replaced by the SD that represents the advince. The algorithm used for the weaving may vary from one approach to other thus resulting in a different SD depending the approach. 

\todo{To illustrate by showing un example of weaving}

The previous approaches manage the composition of models in order to generate a new model. Conversely, composition of language approaches compose languages in order to generate a new language. In these approaches, the correspondences associate concepts of various metamodels in order to generate a new metamodel. The composition is done by a system designer that specifies \emph{What} and \emph{How} concepts from different metamodels are related. In the literature, several techniques exist that compose the structure of languages into a new language. For example, Emerson et al.~\cite{metamodelcompo} propose three of them:
\begin{itemize}
	\item \textbf{Merge:} The merging composes two languages that share a concept. These concepts are used as ``join points" to stitch the two languages together into a unified whole.
	\item \textbf{Interfacing:} When languages do not present joint points, the composition requires an interface. Thus interfacing composes languages that capture distinct but related domains by relying on an interface.
	\item \textbf{Refinement:} One language captures in detail a modeling concept that exists only as a ``blackbox" in a second DSML, \ie the concept defined in one languages refines in other in the second language.
\end{itemize} 
These techniques enable the composition of different languages by relying on the same meta meta model. For example, these techniques have been implemented in the GME framework~\cite{metamodelcompo}, which is based on the meta meta model MetaGME\footnote{http://w3.isis.vanderbilt.edu/projects/gme/meta.html}. The state of art approaches presents variation of these techniques. For instance, Monticore~\cite{monticore} propose two techniques: \emph{inheritance} and \emph{language embedding}. These techniques correspond respectively with refinement and interfacing. A different approach is Neverlang~\cite{neverlang} that enables to build a custom language from features coming from different General Propose Languages. A feature, such as the syntactical aspect of a loop, is encapsulated in a \emph{module block}. The blocks can be composed together for generating the compiler/interpreter of the resulting language. This approach can be understood as a ``interfacing" between general purpose programming languages.

These techniques only provide the means to compose the structure of languages. However, they make explicit neither the semantics of the language nor the semantics of the composition. Differently, \emph{Semantic Anchoring}~\cite{semanticsanchoring} proposes to explicitly define the behavior semantics of a language. Furthermore, it enables the definition of how the semantics can be composed in order to obtain a new semantics. To describe the behavioral semantics of a language, the approach relies on the concept of \emph{Semantic Unit} (SU). From authors, a SU is itself a language that authors identified as ``basic", \eg Finite State Machine (FSM), Timed, Automaton (TA) and Hybrid Automaton (HA). A SU is defined as a AsmL\footnote{http://research.microsoft.com/en-us/projects/asml/} specification in terms of (a) an AsmL Abstract Data Model (which corresponds to the abstract syntax), (b) the behavioral semantics (which is defined by the ASM mathematical framework). Then, the approach proposes to:
\begin{itemize}
	\item Define the syntax of a DSML by its metamodel. 
	\item Define the behavioral semantics of a DSML by specifying the model transformation rules between the metamodel of the DSML and the Abstract Data Model of a semantic unit. 
\end{itemize}    
The main benefice of the use of SUs is they can be composed into a new SU. For example, in~\cite{composemanticanch}, a SU named FSM (Finite State Machine) and a SU named SDF (Synchronized Data Flow) are composed to get a new SU called SU-EFSM. Roughly speaking, the composition is expressed manually using AsmL. Then, the resulting SU can be used to define the behavioral semantics of a language.

\subsection{Discussion}
Composition of Model approaches have achieved to automate the composition between models by relying on a matching and merging operators. In particular, Epsilon eases the specification of such operators by proposing dedicated languages. The specification of the composition can be easily adapted if any metamodel changes. In these approaches, input and output models can conform to different metamodels, however, they must conform to the same meta metamodel. Nerveless, the composition is always between two languages. This limits the use of these approaches in heterogeneous system where models conforming to different languages may be composed. These approaches consider models are only structural thus the semantics is ignoring.     

In~\cite{compostatechartsbib,weavingbib}, approaches have automated the composition of models by considering both syntactic and behavioral similarities. However, in these approaches, the composition is always specified between homogeneous models. Furthermore, operators are encoded inside a framework thus limiting the customization of the operators. In addition, the detection of behavioral similarities between models is not easy or sometimes impossible as shown in~\cite{?}. 

Composition of Languages propose to model heterogeneous system by relying on a unified language. Such a language results from the composition of other languages. Unlike the composition of models, composition of languages approaches have not been automatized. Instead, a system designer has to 1) find correspondences between concepts of different languages and 2) specify how these concepts are related, thus resulting in a new language. The inputs languages and the composed language are conformed to the same meta metamodel. In most of these approaches, correspondences are only between syntactic elements, and only one enables to define behavioral correspondences in order to obtain a new behavioral semantics. In this approach, authors state that its solution is to define semantics for heterogeneous DSMLs as the composition of semantic units. However, it is not clear how this approach is suitable for separation of preoccupation and development of a single system by various domain experts that focus on a specific part of the system. 
