\section{Structural Composition Approaches}
In this section, we focus on the approaches that compose syntactic elements. We begin by approaches that propose to compose the syntax of models. They specify at language level how heterogeneous models can be composed, and then, they apply such specification to automate the composition of models. We finish this section with approaches that compose the syntax of languages into a new syntax. 

 	
 \subsection{Composition of Models Structure}

In this section, we overview approaches that compose the syntax of heterogeneous models into a single model syntax. They specify what concepts from different languages are selected and how they are composed. The specification is applied between models in order to generate a new model that may conform either to the inputs model languages (homogeneous case) or to a different language (heterogeneous case). In the following, we present the approaches by pointing on how they specify the composition.   

Brunet et al.~\cite{mergemanifest} identified that the composition of models always relies on a \emph{merging} operator. In this work, the merging operator takes two models as inputs and applies a \emph{relationship} which specifies how the models are related one to another. This results in a new model. In this work, authors suppose the models conform to the same language, but conclude that the merging operator can be generalized to heterogeneous models (if models conform to the same meta meta model). Several approaches like \emph{Kompose}~\cite{kompose} or \emph{Epsilon}~\cite{epsilon}\footnote{http://www.eclipse.org/epsilon/} rely on operators that are specified between languages but applied between models to generate a new model. 
    		
~\cite{kompose} relies on two generic operators to compose model: \emph{matching} and \emph{merging}. The matching operator specifies which elements in the language can match and how they can match. The merge operator defines how the matched elements are merged. The framework can be adapted to add composition capabilities to a particular language. For instance, Kompose adds composition capabilities to the Ecore metamodel. 
    		
Epsilon~\cite{epsilon}\footnote{http://www.eclipse.org/epsilon/} goes on step forward and purposes dedicated languages for specifying each operator. The matching operator is expressed by using the \emph{Epsilon Comparison Language}\footnote{http://www.eclipse.org/epsilon/doc/ecl/}. The merging operator is expressed by using the \emph{Epsilon Merge Language}\footnote{http://www.eclipse.org/epsilon/doc/eml/}. Theses languages are rule based oriented. The matching rules enable the user to specify a comparison algorithm to identify pairs of matching elements. The matching elements are merged through the merging rules. In this approach, both input models and output model must conform to the same meta meta model (Ecore).
    		
Different that previous approaches, \emph{Aspect Oriented Approaches}~\cite{aop} propose an asymmetric mechanism of composition where one model plays the role of \emph{base} on which other (partial) models named \emph{aspects} are woven. The aspect is made of a \emph{pointcut} and \emph{advice}. A pointcut specifies the \emph{join points} in the base model, \ie the place that will be replaced by the advice during the weaving. The advice contains the (partial) model that is to be woven. This approach is implemented in \emph{AspectJ}\footnote{http://eclipse.org/aspectj/}, \emph{MATA}~\cite{matabib} and \emph{SmartAdapter}~\cite{smartadapbib}. %In both approaches, an aspect is made up with a pattern matching and a composition specification. In SmartAdapter the composition specification is called composition protocol. The application of the aspect model to the base model is achieved in two phases. First, a match of the pattern has to be found in the base model. Once a match is found, the composition specification defines how elements are combined. Both tools are homogeneous approaches, \ie they compose models from the same language.       	

% sumarizes + link
The approaches previously studied specify the composition at language level in order to automate the composition between models syntax. In the next subsection, we overview approaches that specify the composition between languages in order to get a new language syntax. 	 		
    	
\subsection{Composition of Languages Structure}

Language composition approaches propose to compose the syntax of languages into a new syntax. A system designer specifies what concepts from different languages are related thus resulting in a new language. The characteristics of the new language depends on how languages are composed. Several techniques for language composition already exist. For instance, Emerson et al.~\cite{metamodelcompo} propose three techniques to compose the syntax of languages: \emph{Merging}, \emph{Interfacing} and \emph{Refinement}. The merging composes two languages that share a concept. These concepts are used as ``join points" to stitch the two languages together into a unified whole. However, when languages do not present joint points, the composition requires an interface. Thus interfacing composes languages that capture distinct but related domains by relying on an interface. In refinement, one language captures in detail a modeling concept that exists only as a ``blackbox" in a second DSML, \ie the concept defined in one languages refines in other in the second language. These techniques are implemented in the GME framework~\cite{metamodelcompo}. Monticore~\cite{monticore} is a similar approach that implements two techniques for the composition of languages: \emph{Inheritance} and \emph{Language Embedding}. These techniques, however, correspond respectively to refinement and interfacing in~\cite{metamodelcompo}.
	
Conversely, Nervelang~\cite{neverlang} is a framework that builds a custom language from features coming from general purpose languages. A feature, such as the syntactical aspect of a loop, is encapsulated in a \emph{module block}. The blocks can be composed together for generating the compiler/interpreter of the resulting language.  
	
%Also, it is not clear how much these approaches are suitable for separation of preoccupation and development a single system by various domain experts that focus on a specific part of the system.
	 	
\subsection{Discussion}
Composition language approaches tackled the problem of the heterogeneity of languages syntax by relying on a unified language, which is made by composing the syntax of other languages. In a complex system, where several languages are involved, a unique language may be hard to handle and reusability may be limited. Differently, composition models approaches specify the composition at language level but apply between models, thus resulting a new syntactic model. Such a specification seems easier to handle than whole language. 
			 	
The previous approaches only provide the means to compose syntactic elements. A modeling language has also a behavioral semantics that model the behavior of a domain. It is important to specify how different behavioral models interact in order to get the emerging system behavior. In the following, we present approaches that tackle the problem of the composition/coordination of heterogeneous behavioral models. 
