\section{Evaluation}
\label{sec:evaluation}
In this section, we evaluate the benefits of  \bcool in terms of four criteria. Also, we use these criteria to compare our approach with Coordination Languages and Coordination Frameworks. These criteria are:
	\begin{enumerate}
		\item Definition of the coordination between languages;
		\item Generation or synthesis of the coordination between models; 
		\item Analysis capabilities of the coordinated system;
		\item Tooling support.
	\end{enumerate}  

Regarding to first point, in \bcool, the definition of the coordination between languages is based on operators. In particular, coordination rules explicitly define the semantics of the resulting coordination. Notice that an integrator can vary the semantics of the resulting coordination by only modifying the coordination rules of the operators. In frameworks like Ptolemy, an integrator is unable to change the proposed coordination without modifying the framework itself. For instance, in Ptolemy, this means changing the current implementation of a \emph{director} written in Java. The same problem appears in ad-hoc translational approaches~\cite{dinatale}, where the transformation needs to be changed. Since this state-of-the-art approaches is using general-purpose transformation frameworks, this work needs a good knowledge of coordinated languages as well as a good knowledge of the transformation language itself. This is beyond the expected skills of an integrator. In our approach, we are using a language dedicated to language integrator experts thus easing the understanding and adaptation of the \bcool specification. 

Concerning the coordination between models (point number two), the definition of domain specific coordination operators enables the generation of the coordination between models. The manual coordination of models (as proposed by coordination languages) requires a system designer that specifies each relation. The reader can notice that the number of relations increases with the number of model elements involved in the coordination. Our proposition is to leverage this task for the system designer at the language level and then to generate all the required relations accordingly.

%\subsection{Analysis Capabilities}
Regarding system execution and verification (point number three), both coordination languages and coordination frameworks allow to execute the coordinated system, however, the verification varies from one approach to another. Some coordination languages rely on a formal language thus providing verification. Differently, in Ptolemy, the main validation method is based on the execution of the coordinated system~\cite{ptoleframebib}. Furthermore, in Ptolemy and ModHel'X the coordination is expressed in Java so that the verification and validation remains limited. In our approach, by relying on \ccsl to express the coordination, a system designer is able to provide execution and verification of the coordinated system.

%\subsection{Tooling Support}
In terms of tooling support (point number four), current coordination frameworks like Ptolemy~\cite{ptoleframebib} and ModHel'X~\cite{modhelxbib} provide a dedicated environment to develop and coordinate heterogeneous models. They rely on a common syntax based on actors and semantics given by Models of Computation. In addition, they enable the system designer to hierarchically coordinate models. The environments include a graphical editor, an execution engine, plotters and so on. These environments, however, are ad-hoc solutions to manage both the development and the coordination of heterogeneous models. Differently, in our approach, the studio is the integration of several plug-ins that deal with different aspects of the heterogeneous development of models, \eg the GEMOC studio for the design and implementation of DSMLs, the Sirius animator for graphical representation, TimeSquare for the analysis of model execution. Our approach takes advantages of this collaborative environment, and it provides the means for modeling coordination. 

Coordination frameworks do not offer a clear separation between the task of a language integrator and the task of a system designer. They only focus on the task of a system designer. Differently, in our approach, we provide a language workbench to develop \bcool operators and capture coordination patterns between languages. Then, for system designers, we provide a modeling workbench to coordinate, execute and validate models. Therefore, the integrated studio has managed the tasks of both stakeholders by providing dedicated workbenches. 
