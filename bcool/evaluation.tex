\section{Evaluation}
\label{sec:evaluation}
In \bcool, the definition of the coordination between languages is based on operators. In particular, coordination rules explicitly define the semantics of the resulting coordination. The reader can notice that variations of the semantics of the resulting coordination can be done by only modifying the coordination rules of the operators. In frameworks like Ptolemy, such a variation is only supported by modifying the framework itself. For instance, in Ptolemy, this means changing the current implementation of a \emph{director} written in Java. The same problem appears in ad-hoc translational approaches~\cite{dinatale}, where the transformation needs to be changed. Since this state of the art approach is using general-purpose transformation frameworks, this work needs a good knowledge of coordinated languages as well as a good knowledge of the transformation language itself. This is beyond the expected skills of an integrator. In our approach, we are using a language dedicated to integrator experts thus easing the understanding and adaptation of the \bcool specification. 

The definition of domain specific coordination operators enables the automation of the coordination between models. For instance, in the case of the video surveillance system, the application of the operator generates eight \ccsl relations. By manually coordinating the models (as proposed in~\cite{varalarsen:gemoc13} or when using a coordination language), this would require to specify each relation manually. The reader can notice that the number of relations increases with the number of model elements involved in the coordination. For instance, for a system with N cameras, the integrator would need to specify 8*N relations. Our proposition is to leverage this task for the integrator at the language level and then to generate all the required relations accordingly.

Regarding system execution and verification, both coordination languages and coordination frameworks allow to execute the coordinated system, however, the verification varies from one approach to another. Some coordination languages rely on a formal language thus providing verification. Differently, in Ptolemy, the main validation method is based on the simulation of the coordinated system~\cite{girault_lee:composition}. In our approach, by relying on \ccsl, we are able to provide execution and verification of the coordinated system.

\todo{to add evaluation of the tools}

\todo{We consider as related work the coordination frameworks Ptolemy~\cite{ptolemy} and ModHel'X~\cite{Boulanger2008} that provide a dedicated environment to develop and coordinate heterogeneous models. These frameworks rely on a common syntax based on actors and a semantics given by Models of Computation (MoC). Models are represented as actors that can be atomic or composite, \ie made of internal actors. Each composite actor follows an explicit model of computation implemented as a \emph{Domain}. A domain defines the communication semantics and the execution order among internal actors. Based on a fixed syntax, these approaches provide a dedicated environment to develop heterogeneous models. In addition, they enable the system designer to hierarchical coordinate models. The environments include a graphical editor, an execution engine, plotters and so on. These environments, however, are ad-hoc solutions to manage both the development and the coordination of heterogeneous models. Differently, in our approach, the workbench is the integration of several plug-ins that deal with different aspects of the heterogeneous development of models, \eg the GEMOC studio for the design and implementation of DSMLs, the Sirius animator for graphical representation, TimeSquare for the analysis of model execution. Our approach takes advantages of this collaborative environment, and it provides the means for model coordination.}