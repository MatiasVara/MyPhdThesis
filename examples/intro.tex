\section{Introduction}
In this chapter, we validate our approach by using as use case the coordination of the model of a surveillance camera system. The system is composed by a \emph{Camera} and a \emph{Battery Control}. To model this system, we use the TFSM and Activity language. This results in a heterogeneous model that we need to coordinate to get the global behavior.   

To coordinate these models, we propose a set of coordination patterns between the TFSM and Activity languages. More precisely, we propose a hierarchical coordination pattern in which states in a TFSM are synchronized with the execution of activities. This sort of pattern is common in hierarchical coordination frameworks like Ptolemy and ModHel'X. However, in frameworks, the semantics of such hierarchical coordination is hidden inside a tool by using a GPL, \eg Java in Ptolemy. This limits the customization of the coordination and the verification of the coordinated system.  

In this chapter, we propose to make the specification of a hierarchical coordination pattern explicit by using two \bcool operators. One operator specifies a hierarchical coordination in which the entering of states is synchronized with the execution of activities. In addition, we propose a second operator that specifies a timing hierarchical coordination between these languages. More precisely, we specify that the execution of the activities is atomic from point of view of the TFSM language. In other words, during the execution of the activities, the time in a TFSM does not elapse. This operator is also hierarchical but only considers timing aspects.

We organize this chapter as follows. We begin by presenting the heterogeneous model of a surveillance camera system and we propose a set of coordination patterns to coordinate the models. Then, we capture the specification of these coordination patterns by using \bcool operators. We use these operators to generate the coordination model for the models of the surveillance camera system. We then execute the coordinated system by using the GEMOC studio. To finish this chapter, we compare our approach with hierarchical coordination frameworks, and finally we conclude.  