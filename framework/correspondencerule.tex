\section{Correspondence Rule}
	\subsection{Review of Existing Approaches}
A correspondence is an explicit or implicit relationship between model elements. It results from the knowledge of a system designer, which knows what concepts from different models are related. In our context, a correspondence specifies the elements that must be coordinated.
%The concept of correspondence rule can be understood as a connector in ADLs in which the roles refer to languages concepts.  
A correspondence rule is a specification in intention, at the language level, of the correspondences to be created at the model level. In the following we review how the different approaches deal with correspondences and correspondence rules.

\paragraph{Ptolemy/ModHel'X: }
In Ptolemy~\cite{ptoleframebib} and ModHel'X~\cite{modhelxbib}, the notion of composite actors is used to specify the correspondences: when an actor is composite (\ie it contains other actors) then it must coordinates its internal actors.
Consequently, the correspondence rule is encoded in the frameworks by the composition relation established in the actor abstract syntax.

The \emph{pro} of these approaches lies in the simplicity for the designer to express the correspondence since he does it implicitly by the structure of the system model. 

The \emph{cons} of these approaches are twofold. First, using the structure of the model to express the coordination lacks flexibility since the different models (possibly developed in different languages) can hardly be developed independently. Second, it forces the designer to create a hierarchical design based on a single abstract syntax. This can make languages based on totally different structure (like the UML sequence diagram for instance) difficult to introduce in the hierarchical view of the framework.

\paragraph{Di Natale et al: }
In~\cite{dinatale}, a mapping model is used to define the correspondences between the functional and the platform languages. The mapping is defined in a language that constrains what are the concepts from the different languages that can be bound together. For instance, the \emph{SwDeployment} correspondence is mapping two types of elements: one of type \emph{CPU} and another one of type \emph{Task}. 

The \emph{pro} of the approach is the presence of an explicit correspondence model that could be helpful both for comprehension and for traceability.

The \emph{cons} lies in the manual production of the correspondence model (\ie the lack of correspondence rules).

%The approach proposes correspondence rules that are defined at language level, however, the instantiation and binding are still a task of the system designer. The notion of correspondences is thus similar than built-in connectors in Clara~\cite{clarabib} or AADL~\cite{aadlbib}. 


\paragraph{MASCOT: }
In ~\cite{mascotbib}, the correspondences are implicit in the models. It relies on a naming convention to specify when events in SDL and streams in Matlab must be coordinated. It means that a correspondence rule, specifying that the elements to be coordinated must have the same name is encoded in the framework. From this rule and for specific models, the framework can automatically derive the correspondences between some elements.

The \emph{pro} of this approach is to enable relating elements from different languages without making any dependencies between the languages. While a naming convention must be set up in the organization that use the approach, it is flexible in terms of the different languages that can be supported.

The \emph{cons} comes from the direct encoding of the correspondence rule in the framework. This means that comparing the names is the only way to make to elements in correspondence. In some cases it could be interesting to compare more than the names (\eg the types).

\subsection{Requirements}

\todo{
* support for heterogeneous languages \\
* a few dependency as possible\\
* explicit correspondence\\
* tunable correspondence rules\\
}
We want to highlight that in all approaches the correspondences are syntactic, \ie they relate concepts from the syntax of different languages. We identified two ways to express correspondences between syntactic languages elements:
\begin{enumerate}
 \item by using an explicit modeling artifact, \eg mapping model in~\cite{dinatale}, composite actors in~\cite{modhelxbib, ptoleframebib}; 	
  \item by using specific modeling conventions, \eg naming matching in~\cite{mascotbib}.
\end{enumerate}
				
In the first case, correspondences are close to the notion of connectors in ADLs, but with fixed roles that refer to syntactic language elements. Thus, the system designer has to instantiate such modeling artifact in order to specify when concepts are related. For instance, in Ptolemy~\cite{ptoleframebib} and ModHel'X~\cite{modhelxbib}, the system designer instantiates composite actors to define a hierarchical heterogeneous model. Similarly, in~\cite{dinatale}, he has to apply a stereotype to specify where the tasks are deployed into a platform. In these cases, the process of looking for a correspondence between models elements cannot be fully automatized. The approaches need a system designer to decide when a connector must be used. In these cases, the correspondences could be provided by another tool like in~\cite{kofmanbib} where authors use design space exploration techniques to determine the allocation.% By following this idea, the approach of Di Natale et. al~\cite{dinatale} could include an allocation algorithm to automate the deployment of tasks into a platform. 
	\begin{lstlisting}[language=epsilon,
	caption={Matching rule in the Epsilon Comparison Language},
	label={lst:epsilon}, 
	basicstyle=\scriptsize\ttfamily, backgroundcolor=\color{LGrey}, numbers=left, xleftmargin=2pt]
rule MatchEntityWithTerm
match s : Source!Entity
with t : Vocabulary!Term {
compare {
	return s.name = t.name;
}
}
\end{lstlisting}
	
When the correspondence rule relies on a specific modeling convention (case number two), the process of looking for similarities between model elements can be easily automatized. For example, by using the Epsilon Comparison Language (ECL), correspondence rules can be expressed by querying and comparing model elements. For example, Listing~\ref{lst:epsilon} shows the specification in ECL of a matching rule named \emph{MatchEntityWithTerm}. Roughly speaking, the matching rule is used to find correspondences between instances of the \emph{Entity} and \emph{Term} classes (Listing~\ref{lst:epsilon}: line 2 and 3). These classes are defined in different Ecore models. The class Entity is defined in an Ecore referred as \emph{Source} and the class Term is defined in an Ecore referred as \emph{Vocabulary} (Listing~\ref{lst:epsilon}: line 2 and 3). The comparison is done by using the attribute name defined in the context of each class (Listing~\ref{lst:epsilon}: line 5). To express the comparison, the approach relies on a query language named Epsilon Object Language\footnote{http://www.eclipse.org/epsilon/doc/eol/}. When two instances of these classes have the same name, the pairs are matched. The main benefit of the use of a dedicated language is to ease the customization of the correspondences rules thus enabling to adapt them according to the company modeling conventions and the language's nature. Furthermore, conventions are independent of the languages itself, so that it is easy to add support to a new language without changing the current implementation. For example in~\cite{dinatale}, if the platform language is modified to add support to a new hardware, the mapping language must be changed to add a new stereotype that describes the new possible allocation.

Returning to the approach presented in~\cite{sle13-combemale}, the \dse are defined in the context of a metaclass. This can be used to select instances of such \dse (\mse) by querying its context. Furthermore, instances of \dse from different model behavioral interfaces can be selected by comparing elements defined in its context, \ie by using the attribute name. Such a correspondence rule could be implemented by relying on a language to express queries between model elements, \eg OCL, Epsilon Object Language.

In this section, we presented the notion of correspondence rule that relates concepts from different language syntax. Such an artifact is used to identifies when elements from different languages must be coordinated. In the next section, we present the notion of coordination rule that specifies how the selected elements are coordinated.      
			
			
						 
						 %\item For instance, the aim of the ECP is to capture such a convetion by reying on explciit matching rules. It can express, at the language level, queries on different models and specify predicates based on the result of these queries. 
							
		   	%is interesting because it can be used on languages totally independent, \ie which have no idea of the existence of the other one. 
			 %It requires the establishment of modeling conventions but is very agile when it is needed to add a new language into the development process. 
			 %The Epsilon Comparison Language~\cite{epsilonbib} is a dedicated language to express matching relationships between models conforming to different language. 
			 %It can express, at the language level, queries on different models and specify predicates based on the result of these queries. 
			 %An interesting solution could investigate the introduce of such language in the specification of a correspondence matching,  to make the correspondence matching explicit, modular and adaptable.
			%\item The correspondence matching of a coordination pattern could/should be customized according to the actual nature of the languages used (\eg are the languages related somehow or not) or according to the company modeling conventions.
						
						%The first case do not capture all the knowledge of the system designer, which is still injected manually by using a dedicated modeling artifact. It makes lots of sense when the identification of the correspondences is not systematic, like for instance for the allocation of tasks on CPUs. In some cases, this modeling artifact can be created by another dedicated tool (like \cite{kofman:hal-00950533} that uses design space exploration techniques to determine the allocation). It could be interesting to understand how the notions used in the megamodel field~\cite{megamodel} or in multi-view approaches~\cite{ieee42010} can be exploited to specify, in a generic way, the correspondences required in the definition of behavioral coordination patterns between heterogeneous languages.		
				