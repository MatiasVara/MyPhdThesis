\section{Correspondences}
This section presents the notion of \emph{Correspondence}. We begin by reviewing the concept of correspondences in existing approaches. Then, we present requirements to make the correspondences explicit and better customizable.  

\subsection{Review of Existing Approaches}
A correspondence is any explicit or implicit relationship between model elements. Such a relationship is specified by a system designer that knows what elements from different models are related. In the specification of coordination patterns, correspondences are used to selected model elements that must be coordinated. Thus, the selected elements vary depending on the coordination pattern. In the following, we review the existing approaches by focusing on the mechanisms used to get correspondences between model elements.      
%A correspondence rule is a specification in intention, at the language level, of the correspondences to be created at the model level. In the following we review how the different approaches deal with correspondences and correspondence rules.

\paragraph{Ptolemy/ModHel'X: }
In Ptolemy~\cite{ptoleframebib} and ModHel'X~\cite{modhelxbib}, the notion of composite actors is used to specified the correspondences between models: when an actor is composite (\ie it contains other actors) then it coordinates its internal actors. This enables the designing of a system by following a hierarchical scheme where the level $n$ in the hierarchy specifies the coordination of the models that are at the level $n-1$. These frameworks provide a fixed syntax to represent both actors and composite actors. In other words, the unique syntax is used to represent the models together with the correspondences between them. 

The \emph{pro} of these approaches is the simplicity for a designer to express the correspondences. He has only to specify what models are composited and which ones are contained inside. The correspondence is supported by the unique abstract syntax. 

The main \emph{cons} of these approaches is they rely on a unique abstract syntax to describe both  the syntax of models and the syntax of the correspondences. This prevents the independent development of the models (possibly developed in different languages) and the correspondences. In addition, the use of a hierarchical design may limit the number of the supported languages. For instance, the UML sequence diagram could not be easy to introduce in the hierarchical view of the framework.

\paragraph{Di Natale et al: }
In~\cite{dinatale}, a mapping model is used to define the correspondences between the functional and the platform model. The mapping is defined in a dedicated language (\ie mapping language) that fixes what type of concepts from the different languages can be bound together. For instance, the \emph{SwDeployment} correspondence is mapping two types of concepts: one of type \emph{CPU} and another one of type \emph{Task}. 

The \emph{pro} of the approach is that the mapping model defines explicitly the correspondences between the functional and the platform model. This enables reasoning about the related elements, \eg understanding about what elements are related, providing traceability.  

However, in this approach, the building of the mapping model is a task of system designer that has to instantiate and bind the correspondences depending on the current deployment. Thus, the major \emph{cons} of this approach is such a task is still manually done. Although the approach has successfully identified correspondences at language level, it is not able to automate the use of such correspondence.

\paragraph{MASCOT: }
In ~\cite{mascotbib}, the correspondences are implicit in the models. The approach relies on a naming convention to specify when events in SDL and streams in Matlab must be coordinated. In this casem the correspondence relies on a rule that specifies that the elements to be coordinated must have the same name. When this rule is applied between models, the framework can automatically get correspondences between model elements.

The \emph{pro} of this approach is the use of a correspondence rule to select model elements. This makes the approach very flexible in terms of dependencies between the languages, thus easing the support for a new language. In contrast, the approach forces the use of a naming convention in the models.     

The \emph{cons} is the encoding of the correspondence rule in the framework. Thus, the approach is limited to find correspondences by comparing the name of the elements (\ie events from SDL and streams from Matlab).


%the correspondence rule would need to compare also the type.    

\subsection{Requirements}

In the reviewed approaches, we identified different mechanisms to get correspondences between models elements. These correspondences are used in the specification of a coordination pattern by defining what elements must be coordinated. Some approaches rely on a common abstract syntax to identify the elements to be coordinated, others let the designer expressing an explicit mapping between the elements of different languages and some other defines rules allowing the inference of the correspondence for specific models. In the following, we present requirements to improve existing approaches to make them more expressive and better customizable.  

The specification of a coordination pattern may involve several heterogeneous languages. Each language may has its own syntax and behavioral semantics. In this context, an approach that specifies a coordination pattern has to be able to identify correspondences between heterogeneous languages. Thus, our first requirement is the support for heterogeneous languages. Such a requirement disable the possibility to rely on a common abstract syntax like in Ptolemy and ModHel'X. In addition, the support of heterogeneous languages should be done in a way that a new language can be easy to add. For instance, in the case of Di Natale et al., the functional and the platform languages are strongly dependent on the mapping language. Thus, to add support to new language, the mapping language must be modified. Thus, our second requirement is to avoid strong dependencies between the correspondences and the coordinated languages. We believe that the correct specification and use of an homogeneous language interface could also act positively towards this requirement. 

%The first important requirement to face the globalization of modeling languages is the support for heterogeneous languages, not only in terms of semantics but also in terms of syntax. 

%Such support disable the possibility to rely on an artifact of a common abstract syntax like in Ptolemy and ModHel'X. However, it paves the road of an open world with emerging (domain specific) languages as depicted in~\cite{globalization_ieee}.

%Also, in order to address correspondences while taking into account the globalization of modeling languages, it is important to avoid the creation of strong dependencies when specifying the correspondences and the correspondence rules. 

%While this requirements ease the support of new languages, it makes difficult to strongly type or constraint the correspondences. For instance, in \cite{dinatale} the mapping language constrains the mapping model to relate only some specific elements (creating a mapping language with dependencies to the related languages). We believe that the correct specification and use of an homogeneous language interface could also act positively towards this requirement. 

\todo{Je suis ici}

When a system designer tries to understand the correspondence that exists in a coordinated system, it is very useful for her/him to have an explicit representation of these correspondences. It avoids ambiguities in the understanding of the coordination but also it allows external tools to take benefits of the correspondences. This is for instance not the case in the Mascot approach where the correspondences are never reified and only known by the framework and the people aware of the correspondence rules. While it brings benefits, it can be challenging to make an explicit correspondence model between heterogeneous models without dependencies to the different languages used in the system. Once again, language and model interfaces can be very helpful here. 

Last but not least, it is important to specify some correspondence rules at the language level so that the correspondences can be inferred. Additionally, to make it flexible, such correspondences must be made explicit and tunable according to the domain or the organization. 
We can illustrate two families of correspondence rules.
The first one is not generic but consider specific languages on which it can define an analysis to decide what correspondences must be create for some specific models. This is for instance the case in~\cite{kofmanbib} where authors use design space exploration techniques to determine the (best) correspondences between an application and its deployment platform. This could for instance bring benefits to the \cite{dinatale} approach.

The second one is generic but it requires to respect agreements between the organizations developing the different models (like in Mascot). These agreements can be more or less complex. For instance, they can simply rely on a naming convention or they can rely on a more complex ontology based system. These agreements determine how to determine the elements that are ``corresponding''. To illustrate our proposal we quickly present the Epsilon Comparison Language (ECL~\cite{TODO_ECLComparisonLanguage}), a language dedicated to the expression of correspondence rules. In Epsilon Comparison Language the correspondence rules are expressed by querying and then comparing model elements. For example, Listing~\ref{lst:epsilon} shows the specification in ECL of a matching rule named \emph{MatchEntityWithTerm}. Roughly speaking, the matching rule is used to find correspondences between instances of the \emph{Entity} and \emph{Term} classes (Listing~\ref{lst:epsilon}: line 2 and 3). These classes can be defined in different Ecore models. The class Entity is defined in an Ecore referred as \emph{Source} and the class Term is defined in an Ecore referred as \emph{Vocabulary} (Listing~\ref{lst:epsilon}: line 2 and 3). The comparison is done by using the attribute name defined in the context of each class (Listing~\ref{lst:epsilon}: line 5). To express the comparison, the approach relies on a query language named Epsilon Object Language\footnote{http://www.eclipse.org/epsilon/doc/eol/}. When two instances of these classes have the same name, the pairs are matched.

\todo{adapt the Source!Entity and Vocabulary!Term to the Mascot case. Perhaps you can also do another one representing the Ptolemy case ? (not sure about this last point)}
\begin{lstlisting}[language=epsilon, caption={The Mascot correspondence rule in the Epsilon Comparison Language}, label={lst:epsilon}, 	basicstyle=\scriptsize\ttfamily, backgroundcolor=\color{LGrey}, numbers=left, xleftmargin=2pt]
rule MatchEntityWithTerm
  match s : Source!Entity
  with t : Vocabulary!Term 
  {
    compare {
	    return s.name = t.name;
    }
  }
\end{lstlisting}

The main benefit of the use this kind of dedicated language is to ease the customization of the correspondences rules thus enabling to adapt them according to the company modeling conventions and the language's nature. For instance in listing \ref{lst:epsilon} the matching is equivalent to the one encoded in Mascot. However it can be customized to add another criteria for matching.
 Furthermore, conventions are independent of the languages themselves, so it is easy to add support for a new language without changing the approach framework.


%not here !
%Returning to the approach presented in~\cite{sle13-combemale}, the \dse are defined in the context of a metaclass. This can be used to select instances of such \dse (\mse) by querying its context. Furthermore, instances of \dse from different model behavioral interfaces can be selected by comparing elements defined in its context, \ie by using the attribute name. Such a correspondence rule could be implemented by relying on a language to express queries between model elements, \eg OCL, Epsilon Object Language.

In this section, we presented how the notion of correspondences and correspondence rules are dealt with in different approaches focusing on the specification of coordination patterns. Such an artifact is used to identifies when instances of concepts from different languages must be coordinated. 
We proposed four requirements for a flexible implementation of correspondence and correspondence rules. They may: 
\begin{enumerate}
\item provide support for heterogeneous languages;
\item avoid creating dependencies between a predefined set of languages to enable the support of new languages;
\item be made explicit to ease the identification of what are the correspondences between model elements and to understand the rational of such correspondences (by having access to the correspondence rule);
\item be adaptable to specific organizations or domains to avoid over constraining the agreements different organizations whose models must be coordinated.
\end{enumerate}

In the next section, we present the notion of coordination rule that specifies how the selected elements are coordinated.      
							
%The first case do not capture all the knowledge of the system designer, which is still injected manually by using a dedicated modeling artifact. It makes lots of sense when the identification of the correspondences is not systematic, like for instance for the allocation of tasks on CPUs. In some cases, this modeling artifact can be created by another dedicated tool (like \cite{kofman:hal-00950533} that uses design space exploration techniques to determine the allocation). It could be interesting to understand how the notions used in the megamodel field~\cite{megamodel} or in multi-view approaches~\cite{ieee42010} can be exploited to specify, in a generic way, the correspondences required in the definition of behavioral coordination patterns between heterogeneous languages.		
				