\section{Correspondence Rule}
	\subsection{Overview}
A correspondence rule is any explicit or implicit relationship between languages elements. It captures the know-how of a system designer that knows what concepts from different languages are related. In other words, it represents the ``tricks'' that a system designer uses to know what elements must be coordinated. %The concept of correspondence rule can be understood as a connector in ADLs in which the roles refer to languages concepts.  

In~\cite{dinatale}, the mapping model is used to define correspondences between the functional and the platform languages. The approach proposes dedicated stereotypes that fix what type of elements from the languages can be bound. For instance, the use of the \emph{SwDeployment} stereotype fixes the binding between two type of elements: one of type \emph{CPU} and another one of type \emph{Task}. The approach proposes correspondence rules that are defined at language level, however, the instantiation and binding are still a task of the system designer. The notion of correspondences is thus similar than built-in connectors in Clara~\cite{clarabib} or AADL~\cite{aadlbib}. 
		
Ptolemy~\cite{ptoleframebib} and ModHel'X~\cite{modhelxbib} model the correspondence between models by providing composite actors. These frameworks provide a fixed syntax in which composite actors are first class object. The system designer has to manually specify what models are composited and which ones are contained inside. This enables the designing of a system by following a hierarchical scheme where the level $n$ in the hierarchy specifies the coordination of the models that are at the level $n-1$.

MASCOT~\cite{mascotbib} do not model explicitly the correspondences, instead, it relies on a naming convention to specify what events in SDL and streams in Matlab must be coordinated. This results that the Matlab script must use the same name for the stream than the name of the events in SDL model.  

\subsection{Discussion}
In the reviewed approaches, we identified two ways to express the correspondences between languages elements:
\begin{enumerate}
 \item by using an explicit modeling artifact, \eg mapping model in~\cite{dinatale}, composite actors in~\cite{modhelxbib, ptoleframebib}; 	
  \item by using specific modeling conventions, \eg naming matching in~\cite{mascotbib}.
\end{enumerate}
				
In the first case, correspondences are close to the notion of connectors in ADLs, but with fixed roles that refer to language elements. Thus, the system designer has to instantiate such modeling artifact in order to specify when concepts are related. For instance, in Ptolemy~\cite{ptoleframebib} and ModHel'X~\cite{modhelxbib}, the system designer instantiates composite actors to define a hierarchical heterogeneous model. Similarly, in~\cite{dinatale}, he has to instantiate a stereotype to specify a which task is deployed into a platform. In these cases, the process of looking for a correspondence between models elements cannot be fully automatized. The approaches need a system designer to decide when a connector must be used. In these cases, the correspondences could be provided by another tool like in~\cite{kofmanbib} where authors use design space exploration techniques to determine the allocation.% By following this idea, the approach of Di Natale et. al~\cite{dinatale} could include an allocation algorithm to automate the deployment of tasks into a platform. 
	\begin{lstlisting}[language=epsilon,
	caption={Matching rule in the Epsilon Comparison Language},
	label={lst:epsilon}, 
	basicstyle=\scriptsize\ttfamily, backgroundcolor=\color{LGrey}, numbers=left, xleftmargin=2pt]
rule MatchEntityWithTerm
match s : Source!Entity
with t : Vocabulary!Term {
compare {
	return s.name = t.name;
}
}
\end{lstlisting}
	
When the correspondence rule relies on a specific modeling convention (case number two), the process of looking for similarities between model elements can be easily automatized. For example, by using the Epsilon Comparison Language (ECL), correspondences rule can be explicitly expressed by querying and comparing model elements. For example, Listing~\ref{lst:epsilon} shows the specification in ECL of a matching rule named \emph{MatchEntityWithTerm}. Roughly speaking, the matching rule is used to find correspondences between instances of the \emph{Entity} and \emph{Term} classes (Listing~\ref{lst:epsilon}: line 2 and 3). These classes are define in different Ecore models. The class Entity is defined in an Ecore referred as \emph{Source} and the class Term is defined in an Ecore referred as \emph{Vocabulary} (Listing~\ref{lst:epsilon}: line 2 and 3). The comparison is done by using the attribute name defined in the context of each class (Listing~\ref{lst:epsilon}: line 5). Thus, when two instances of these classes have the same name, the pairs are matched. The main benefit of the use of a dedicated language is to ease the customization of the correspondences rules thus enabling to adapt them according to the company modeling conventions and the language's nature. Furthermore, convention are independent of the languages itself, so that it is easy to add support to a new language without changing the current implementation. For example in~\cite{dinatale}, if the platform language is modified to add support to a new hardware, the mapping language must be changed to add a new stereotype that describes the new possible allocation.

Returning to the approach presented in~\cite{sle13-combemale}, the \dse are defined in the context of a metaclass. This can be used to select instances of such \dse (\mse) by querying its context. Furthermore, instances of \dse from different model behavioral interfaces can be selected by comparing elements defined in its context, \ie by using the attribute name. Such a correspondence rules can be implemented by relying on a language to express queries between model elements, \eg OCL, Epsilon Object Language~\footnote{http://www.eclipse.org/epsilon/doc/eol/}.      
			
			
						 
						 %\item For instance, the aim of the ECP is to capture such a convetion by reying on explciit matching rules. It can express, at the language level, queries on different models and specify predicates based on the result of these queries. 
							
		   	%is interesting because it can be used on languages totally independent, \ie which have no idea of the existence of the other one. 
			 %It requires the establishment of modeling conventions but is very agile when it is needed to add a new language into the development process. 
			 %The Epsilon Comparison Language~\cite{epsilonbib} is a dedicated language to express matching relationships between models conforming to different language. 
			 %It can express, at the language level, queries on different models and specify predicates based on the result of these queries. 
			 %An interesting solution could investigate the introduce of such language in the specification of a correspondence matching,  to make the correspondence matching explicit, modular and adaptable.
			%\item The correspondence matching of a coordination pattern could/should be customized according to the actual nature of the languages used (\eg are the languages related somehow or not) or according to the company modeling conventions.
						
						%The first case do not capture all the knowledge of the system designer, which is still injected manually by using a dedicated modeling artifact. It makes lots of sense when the identification of the correspondences is not systematic, like for instance for the allocation of tasks on CPUs. In some cases, this modeling artifact can be created by another dedicated tool (like \cite{kofman:hal-00950533} that uses design space exploration techniques to determine the allocation). It could be interesting to understand how the notions used in the megamodel field~\cite{megamodel} or in multi-view approaches~\cite{ieee42010} can be exploited to specify, in a generic way, the correspondences required in the definition of behavioral coordination patterns between heterogeneous languages.		
				