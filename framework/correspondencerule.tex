\section{Correspondences Rules}

\todo{To introduce the difference between correspondences and correspondences rules}

This section presents the notion of \emph{Correspondence Rules}. We begin by reviewing the concept of correspondences rules in existing approaches. Then, we present requirements to make the correspondences rules explicit and better customizable.  

\subsection{Review of Existing Approaches}
A correspondence is any explicit or implicit relationship between model elements. Such a relationship is specified by a system designer that knows what elements from different models are related. In the specification of coordination patterns, correspondences specify the model elements that must be coordinated. To automate the process of looking for correspondences between models, the specification of a coordination pattern involves the definition of a correspondence rule at language level. Such a rule defines, in intention, the correspondences to be instantiated at model level. In the following, we review the existing approaches by focusing on the mechanisms used to get correspondences between model elements, \ie correspondences rules.       
%A correspondence rule is a specification in intention, at the language level, of the correspondences to be created at the model level. In the following we review how the different approaches deal with correspondences and correspondence rules.

\paragraph{Ptolemy/ModHel'X: }
In Ptolemy~\cite{ptoleframebib} and ModHel'X~\cite{modhelxbib}, the notion of composite actors is used to specified the correspondences between models: when an actor is composite (\ie it contains other actors) then it coordinates its internal actors. This enables the designing of a system by following a hierarchical scheme where the level $n$ in the hierarchy specifies the coordination of the models that are at the level $n-1$. These frameworks provide a fixed syntax to represent both actors and composite actors. In other words, the unique syntax is used to represent the models together with the correspondences between them. The correspondence rule is encoded in the syntax of the framework by the composite actor relationship.  

The \emph{pro} of these approaches is the simplicity for a designer to express the correspondences. He has only to specify what models are composited and which ones are contained inside. The correspondence is supported by the unique abstract syntax. 

The main \emph{cons} of these approaches is they rely on a unique abstract syntax to describe both  the syntax of models and the syntax of the correspondences. This prevents the independent development of the models (possibly developed in different languages) and the correspondences. In addition, the use of a hierarchical design may limit the number of the supported languages. For instance, the UML sequence diagram could not be easy to introduce in the hierarchical view of the framework.

\paragraph{Di Natale et al: }
In~\cite{dinatale}, a mapping model is used to define the correspondences between the functional and the platform model. The mapping is defined in a dedicated language (\ie mapping language) that fixes what type of concepts from the different languages can be bound together. For instance, the \emph{SwDeployment} correspondence is mapping two types of concepts: one of type \emph{CPU} and another one of type \emph{Task}. 

The \emph{pro} of the approach is that the mapping model defines explicitly the correspondences between the functional and the platform model. This enables reasoning about the related elements, \eg understanding about what elements are related, providing traceability.  

However, in this approach, the building of the mapping model is a task of system designer that has to instantiate and bind the correspondences depending on the current deployment. Thus, the major \emph{cons} of this approach is such a task is still manually done. Although the approach has successfully identified correspondences at language level, it is not able to automate the use of such correspondence.

\paragraph{MASCOT: }
In ~\cite{mascotbib}, the correspondences are implicit in the models. The approach relies on a naming convention to specify when events in SDL and streams in Matlab must be coordinated. In this casem the correspondence relies on a rule that specifies that the elements to be coordinated must have the same name. When this rule is applied between models, the framework can automatically get correspondences between model elements.

The \emph{pro} of this approach is the use of a correspondence rule to select model elements. This makes the approach very flexible in terms of dependencies between the languages, thus easing the support for a new language. In contrast, the approach forces the use of a naming convention in the models.     

The \emph{cons} is the encoding of the correspondence rule in the framework. Thus, the approach is limited to find correspondences by comparing the name of the elements (\ie events from SDL and streams from Matlab).


%the correspondence rule would need to compare also the type.    

\subsection{Requirements}

In the reviewed approaches, we identified different mechanisms to get correspondences between models elements. These correspondences are used in the specification of a coordination pattern by defining what elements must be coordinated. Ptolemy and ModHel'X rely on a common abstract syntax to identify the elements to be coordinated; Di Natale et al. propose a dedicated language to express an explicit mapping between the elements of different models; and MASCOT defines some rules that allow the inference of the correspondences for specific models. In the following, we present requirements to improve the way that existing approaches get correspondence between heterogeneous models. The requirements aims at making them more expressive and better customizable.  

% Context + Requierement + Explication about why the requierement + discussion pros/cons/impact

The specification of a coordination pattern may involve several heterogeneous languages. Each language may has its own syntax and behavioral semantics. In this context, an approach that specifies a coordination pattern has to be able to identify correspondences between heterogeneous languages. Thus, our first requirement is the support for heterogeneous languages. Such a requirement disable the possibility to rely on a common abstract syntax like in Ptolemy and ModHel'X.

The support of heterogeneous languages should be done in a way that a new language can be easy to add or change. For instance, in the case of Di Natale et al., the mapping language (\ie the language used for the correspondences) depends on the coordinated languages, (\ie the functional and the platform languages). If any of these languages are modified, the mapping language must be changed. Thus, our second requirement is to avoid strong dependencies between the correspondences and the coordinated languages. We believe that the correct specification and use of a homogeneous language interface could also act positively towards this requirement. 

%The first important requirement to face the globalization of modeling languages is the support for heterogeneous languages, not only in terms of semantics but also in terms of syntax. 

%Such support disable the possibility to rely on an artifact of a common abstract syntax like in Ptolemy and ModHel'X. However, it paves the road of an open world with emerging (domain specific) languages as depicted in~\cite{globalization_ieee}.

%Also, in order to address correspondences while taking into account the globalization of modeling languages, it is important to avoid the creation of strong dependencies when specifying the correspondences and the correspondence rules. 

%While this requirements ease the support of new languages, it makes difficult to strongly type or constraint the correspondences. For instance, in \cite{dinatale} the mapping language constrains the mapping model to relate only some specific elements (creating a mapping language with dependencies to the related languages). We believe that the correct specification and use of an homogeneous language interface could also act positively towards this requirement. 

To understand how particular system is coordinated, it is important to clearly identify the elements that are related. This has already identified in the frameworks Ptolemy and ModHel'X by providing a dedicated syntax to specify the coordination. Unlike these approaches, In Mascot, the correspondence rule is implicit into the approach thus making necessary to read the documentation to realize that the correspondences relies on a naming convention. Thus, our third requirement is the explicit representation of the correspondences between models elements. This requirement enables a system designer to understand the correspondences that exist in the system. Also, it allows external tool to take advantages of the correspondences. Such a requirement aims at improving the identification of the elements that are coordinated. Such explicit representation must be done without creating dependencies between the languages used in the system in order to fulfill the second requirement. Once again, language and model interfaces can be very helpful here
	
	%\item When a system designer tries to understand the correspondence that exists in a coordinated system, it is very useful for her/him to have an explicit representation of these correspondences.
	
	%\item  It avoids ambiguities in the understanding of the coordination but also it allows external tools to take benefits of the correspondences.
	
	%\item This is for instance not the case in the Mascot approach where the correspondences are never reified and only known by the framework and the people aware of the correspondence rule.
	
	%\item While it brings benefits, it can be challenging to make an explicit correspondence model between heterogeneous models without dependencies to the different languages used in the system.
	
	%\item  Once again, language and model interfaces can be very helpful here. 


In MASCOT, authors identified that by relying on correspondences rules the process for looking for similarities between models elements can be easily automatized. These rules are specified at language level and enable to get correspondences between two particular models. However, in MASCOT, these rules are encoded and not well defined. To improve the definition of correspondence rules, our fourth requirement is that correspondences rules must be explicitly defined and customizable depending on the domain and conventions followed by different system engineers.
	
A correspondence rule could be used to capture correspondences between models that conform to two particular languages. This is the case in~\cite{kofmanbib} where authors use design space exploration techniques to determine the (best) correspondences between an application and its deployment platform. Also, correspondences rules can be used to capture conventions followed by system engineers in an organization. The complexity of the conventions can vary from a simple naming convention (\eg MASCOT) to a more complex ontology based system. Based on such conventions, correspondence rules can determine what elements from different models must be coordinated.    

\begin{lstlisting}[language=epsilon, caption={The Mascot correspondence rule in the Epsilon Comparison Language}, label={lst:epsilon}, 	basicstyle=\scriptsize\ttfamily, backgroundcolor=\color{LGrey}, numbers=left, xleftmargin=2pt]
rule MatchEventWithStream
match s : SDL!Event
with t : Matlab!Stream 
{
compare {
return s.name = t.name;
}
}
\end{lstlisting}

To make correspondence rules explicit, a dedicated language should be used. To illustrate this, we propose to use the Epsilon Comparison Language (ECL~\cite{TODO_ECLComparisonLanguage}) to sketch the definition of the correspondence rule in the case of MASCOT. The ECL is a language dedicated to the expression of correspondence rules. In this language, correspondence rules are expressed by querying and then comparing model elements. For example, Listing~\ref{lst:epsilon} shows the specification in ECL of a matching rule named \emph{MatchEventWithStream}. Roughly speaking, the matching rule is used to find correspondences between instances of the \emph{Event} and \emph{Stream} classes (Listing~\ref{lst:epsilon}: line 2 and 3). These classes can be defined in different metamodels (\ie Ecore models). The class Event is defined in an metamodel referred as \emph{Source} and the class Term is defined in an metamodel referred as \emph{Vocabulary} (Listing~\ref{lst:epsilon}: line 2 and 3). The comparison is done by using the attribute name defined in the context of each class (Listing~\ref{lst:epsilon}: line 5). To express the comparison, the approach relies on a query language named Epsilon Object Language\footnote{http://www.eclipse.org/epsilon/doc/eol/}. When two instances of these classes have the same name, the pairs are matched.
	
The main benefit of the use of such a dedicated language is to ease the customization of the correspondences rules, thus enabling to adapt them according to the company modeling conventions and the language's nature. For instance in listing \ref{lst:epsilon} the matching is equivalent to the one encoded in Mascot. However, it can be customized to add another criteria for matching. Furthermore, conventions are independent of the languages themselves, so it is easy to add support for a new language without changing the approach framework.
	

In this section, we have presented some requirements to improve the way that approaches get correspondences between models. In the specification of a coordination pattern, correspondences are used to identify which elements from different models must be coordinated. We proposed four requirements for a flexible implementation of correspondences. They should: 
\begin{enumerate}
\item provide support for heterogeneous languages;
\item avoid creating dependencies between a predefined set of languages to enable the support of new languages;
\item be made explicit to ease the identification of what are the correspondences between model elements and to understand the rational of such correspondences (by having access to the correspondence rule);
\item be adaptable to specific organizations or domains to avoid over constraining the agreements different organizations whose models must be coordinated.
\end{enumerate}

In the next section, we present the notion of coordination rule that specifies how the elements selected by a correspondence must be coordinated.     
	
	
%how the notion of correspondences and correspondence rules are dealt with in different approaches focusing on the specification of coordination patterns. Such an artifact is used to identifies when instances of concepts from different languages must be coordinated. 
					
%The first case do not capture all the knowledge of the system designer, which is still injected manually by using a dedicated modeling artifact. It makes lots of sense when the identification of the correspondences is not systematic, like for instance for the allocation of tasks on CPUs. In some cases, this modeling artifact can be created by another dedicated tool (like \cite{kofman:hal-00950533} that uses design space exploration techniques to determine the allocation). It could be interesting to understand how the notions used in the megamodel field~\cite{megamodel} or in multi-view approaches~\cite{ieee42010} can be exploited to specify, in a generic way, the correspondences required in the definition of behavioral coordination patterns between heterogeneous languages.	


%not here !
%Returning to the approach presented in~\cite{sle13-combemale}, the \dse are defined in the context of a metaclass. This can be used to select instances of such \dse (\mse) by querying its context. Furthermore, instances of \dse from different model behavioral interfaces can be selected by comparing elements defined in its context, \ie by using the attribute name. Such a correspondence rule could be implemented by relying on a language to express queries between model elements, \eg OCL, Epsilon Object Language.

	
	%\item It is important to specify some correspondence rules at the language level so that the correspondences can be inferred. 
	
	
	
	
	
	%\item The first considers specific languages on which it can define an analysis to decide what correspondences must be create for some specific models. 
	
				