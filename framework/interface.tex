\section{Language Behavioral Interface}
	\subsection{Overview}
	\begin{itemize}
		\item To capture the specification of a coordination pattern between languages, approaches rely on partial knowledge on the syntax and behavioral semantic of the languages they coordinate, \ie a language behavioral interface. At the model level, the notion of interface is used to expose information of model behavior in order to ease its coordination (see Section~\ref{ch:background}). Similarly, at language level, a behavioral interface is used to expose only a part of the syntax and semantic of language to ease its coordination. In this sense, a language behavioral interface is specific for coordination purpose.   
		
		\item In the state of art approaches, the notion of language behavioral varies depending on the approach. For example in Ptolemy~\cite{ptoleframebib} and ModHel'X~\cite{modhelxbib}, the behavior of models is described by a Director that implements a domain \eg FSM, DE, SDF. The implementation of a domain is done in Java. To communicate different directors that may implement different domains, each director has a Java interface made of methods. The interface provides a homogeneous view of the behavioral semantics of the domain. Each method has a semantics that is expressed in natural language. For instance, a part of the \emph{fire()} function description is: ``\emph{Typically, the fire() method performs the computation associated with an actor}''. The pattern is captured by specifying how methods from different interfaces are invoked. Such specification is encoded into the framework. To summarize, in these approaches, the language behavioral interface is: 1) generic and made of methods in java, 2) relies on a naming convention to identify the semantics. This remains very informal since the same methods may be have a different meaning or no meaning in different domains.    
		
		%\footnote{the Executable interface, cf. http://chess.eecs.berkeley.edu/ptexternal/src/ptII/doc/codeDoc/ptolemy/actor/Executable.html}
		\item While in the previous approaches, the notion of interface is explicit and generic, in~\cite{dinatale}, there is non such a notion of interface. However, the mapping language has partial information about the syntax of both the functional and the platform languages. The mapping language references some syntactic elements from both languages (\eg \emph{Task}s and \emph{Cpu}s). In addition, the translational semantics of the mapping language is based on the knowledge about the translational semantics of the platform and functional languages. More precisely the mapping semantics needs to know about the naming conventions from the other translational semantics. In~\cite{dinatale}, this required knowledge is kept implicit and hard coded in the translation semantics of the mapping language. However, this information about the language semantics could be exposed in a language interface to avoid hard coding it. 
			
		\item In Mascot~\cite{mascotbib}, the coordination is not symmetric since Matlab scripts are embedded in an SDL model. \todo{As a consequence the Matlab interface is used but not the SDL interface.} The authors identified two main elements about the Matlab language. First they depict the different kinds of communication used from and to Matlab. Second they characterize the Model of Computation used by the Matlab simulation engine as being Petri Net. They based the coordination on this knowledge so that these pieces of information act as the language interface of the Matlab language. \todo{On the other side, it is mandatory in the Matlab script to use the same name for the stream then the name of the signals from and to the SDL wrappers of the SDL model. Consequently, it means this approach relies on naming convention to specify the correspondence matching.}
		\end{itemize}
	\subsection{Discussion}
	\begin{itemize}
	
	    	\item All the approaches studied retrieve information on the syntax and/or behavioral semantics of the languages they coordinate. Only \cite{ptolemybib} and \cite{modhelxbib} made explicit the notion of interface; \cite{MarcoModels2014} and \cite{mascotbib} retrieved the information implicitly from the definition of the languages. 
	    	Using an explicit language interface is a way to obtain a language independent representation of the behavioral semantics. In this case, the approaches can add support to new languages with a minimum effort since they are seen homogeneously. However, because the language interface definition used in \cite{ptolemybib} and \cite{modhelxbib} provides only a list of functions, it requires a deep understanding of the underlying framework to be able to specify correct coordination patterns. 
	    	\todo{An interesting research direction could be to adapt the notion of interface automata proposed in~\cite{henzingerIA} to specify the acceptable protocol between the calls of the functions that implements the semantics of the language.} 
	    	
	    	\item At the model level, \cite{garlansoftarchbib} explains that there are important benefits of using events (with implicit invocation) in the component interfaces because it provides strong support for reuse and evolution of components. 
	    	In~\cite{coordinainterfacebib}, authors go further by proposing a component interface that contains events but also properties specified in a temporal logic language. These properties abstract the behavior of the components.
	    	
	    	\item \todo{ Several causal representations from the concurrency theory are used to capture event-based behavioral interface. A causal representation captures the concurrency, dependency and conflict relationships among actions in a particular program. For instance, an event structure~\cite{eventStructures} is a partial order of events, which specifies the, possibly timed, causality relations as well as conflict relations (\ie exclusion relations) between actions of a concurrent system. This fundamental model is powerful because it totally abstracts data and program structure to focus on the partial ordering of actions. It specifies, \emph{in extension} and \emph{in order}, the set of actions that can be observed during the program execution. An event structure can also be specified \emph{in intention} to represent the set of observable event structures during an execution (see \eg\cite{tr:ccsl} or \cite{tagmachine}).}
	    	
	    	\item With the goal to provide a rich event based language interface, \cite{sle13combemalebib} proposed to specify a behavioral language interface based on the notion of symbolic event structure. The symbolic event structure is linked to both the abstract syntax and the functions implementing the semantics. It exhibits the concurrency and the causalities between the functions implementing the semantics and link them with the concepts of the language.
	    	
	    	\item \todo{In~\cite{sle13-combemale} elements of event structures are reified at the language level to propose a behavioral interface based on sets of \emph{event types} and \emph{contraints}. Event types (named \dse for Domain Specific Event) are defined in the context of a metaclass of the abstract syntax (\as), and abstract the relevant semantic actions. Jointly with the \dse, related constraints give a symbolic (intentional) representation of an event structure. With  such an interface, the concurrency and time-related aspects of the language behavioral semantics are explicitly exposed and the coordination is event-driven and non intrusive.}
	    	\item \todo{Then, for each model conforming to the language, the model behavioral interface is a specification, in intention, of an event structure whose events (named \mse for Model Specific Event) are instances of the \dse defined in the language interface. While \dse are attached to a metaclass, \mse are linked to one of its instances. The causality and conflict relations of the event structure are a model-specific unfolding of the constraints specified in the language behavioral interface. Just like event structures were initially introduced to unfold the execution of Petri nets, we use them here to unfold the execution of models.}
	    	\end{itemize}